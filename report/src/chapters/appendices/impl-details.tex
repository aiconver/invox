\section{Consistency Formatting (CF) Agent}
\label{app:cf-impl}

Listing~\ref{lst:cf-transforms} shows the main helper functions used by the CF agent for deterministic normalization. These correspond to the transformation rules described in Section~\ref{subsec:impl-cf}.

\begin{lstlisting}[language=Java, caption={CF agent transformation function signatures}, label={lst:cf-transforms}]
function normalizeDate(value: string): string | null;

function normalizeNumber(value: string): number | null;

function validateEnum(value: string, options: string[]): string | null;

function joinMultiValue(values: any[]): string | null;

function normalizeText(value: string): string | null;
\end{lstlisting}

\section{IE Agent Supporting Types}
\label{app:ie-types}

Listing~\ref{lst:ie-types} defines the supporting types used by the IE agent to represent current and filled field values.

\begin{lstlisting}[language=Java, caption={Supporting types for the IE agent}, label={lst:ie-types}]
interface CurrentFieldValue {
  value: any;
  locked?: boolean;             // If true, field is never overwritten
  source?: "ai" | "manual";     // Origin of current value
}

interface FilledField {
  value: any;
  changed: boolean;             // Whether value differs from current
  previousValue?: any;          // Only present if changed=true
  source: "ai" | "manual";
  confidence?: number;          // Optional: model's certainty estimate
}
\end{lstlisting}

\section{Verification Agent API}
\label{app:ver-api}

Listing~\ref{lst:ver-api} provides the TypeScript interfaces for the verification agent, as described conceptually in Section~\ref{subsec:impl-ver}.

\begin{lstlisting}[language=Java, caption={Verification agent API contract}, label={lst:ver-api}]
interface VerificationInput {
  candidates: Record<string, FilledField> | Record<string, FilledField>[];
  transcript: string;           // Combined old + new for context
  fields: FormTemplateField[];
  currentValues?: Record<string, CurrentFieldValue>;
}

interface VerificationOutput {
  filled: Record<string, FilledField>;
  confidence: Record<string, number>;   // Calibrated per-field confidence
  issues?: Array<{
    field: string;
    type: "missing" | "conflict" | "low_conf" | "invalid";
    detail: string;
    action?: "requery" | "clarify" | "manual_review";
  }>;
  decisions?: Array<{             // Only for ensemble strategies
    field: string;
    decision: "gpt" | "gemini" | "merge" | "keep_current";
    reason: string;
  }>;
}
\end{lstlisting}

\section{Orchestrator Implementation}
\label{app:orchestrator-impl}

Listing~\ref{lst:orchestrator-core} presents the core orchestration logic as implemented in the \texttt{Orchestrator} class. This corresponds to the conceptual pipeline described in Section~\ref{subsec:impl-orchestration}.

\begin{lstlisting}[language=Java, caption={Core orchestration logic of the Invox pipeline}, label={lst:orchestrator-core}]
class Orchestrator {
  async processTemplate(input: ProcessingRequest): Promise<FinalTemplate> {
    // Step 1: Transcription (optional)
    const transcript = input.audio 
      ? await stt.transcribe(input.audio)
      : { transcript: input.text, language: input.lang ?? "en" };

    // Step 2: Retrieval (RAG)
    const examples = await rag.retrieve(
      transcript.transcript,
      input.fields,
      input.templateId
    );

    // Step 3: Extraction (strategy-dependent)
    const extraction = await this.runStrategy({
      strategy: input.strategy,
      transcript: transcript.transcript,
      fields: input.fields,
      currentValues: input.currentValues,
      fewShots: examples.examples,
      ...input.metadata,
    });

    // Step 4: Formatting (deterministic normalization)
    const normalized = await cf.normalize(extraction.filled, input.fields);

    // Step 5: Verification (completeness + consistency)
    const verified = await ver.verify({
      candidates: normalized,
      transcript: transcript.transcript,
      fields: input.fields,
      currentValues: input.currentValues,
    });

    // Step 6: Clarification loop (if needed)
    if (verified.issues?.some(i => i.action === "requery")) {
      // Re-run IE with hints from VER, then re-verify
    }

    return {
      filled: verified.filled,
      confidence: verified.confidence,
      issues: verified.issues,
      model: extraction.model,
      transcript: transcript.transcript,
    };
  }

  private async runStrategy(params: StrategyParams): Promise<IEOutput> {
    switch (params.strategy) {
      case "S1": return await singleLlmAllField(params);
      case "S2": return await singleLlmOneField(params);
      case "S3": return await dualLlmAllField(params);
      case "S4": return await multiLlmOneField(params);
    }
  }
}
\end{lstlisting}

